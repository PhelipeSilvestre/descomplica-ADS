# Entendendo a Recurs√£o II

Fun√ß√µes recursivas s√£o aquelas que chamam a si mesmas, seja direta ou indiretamente, como parte de sua execu√ß√£o. Isso permite que uma tarefa complexa seja dividida em subproblemas menores do mesmo tipo.

A recurs√£o √© frequentemente usada para resolver problemas que podem ser decompostos em vers√µes menores do mesmo problema, como na defini√ß√£o de sequ√™ncias matem√°ticas (como a sequ√™ncia de Fibonacci) ou na manipula√ß√£o de estruturas de dados como √°rvores.

Exemplo: Fatorial de um N√∫mero
O fatorial de um n√∫mero ùëõ n (representado como ùëõ!) √© o produto de todos os inteiros positivos menores ou iguais a ùëõ. Por exemplo:

5!=5√ó4√ó3√ó2√ó1=120

### Implementa√ß√£o Recursiva em Java

Vamos implementar uma fun√ß√£o recursiva para calcular o fatorial de um n√∫mero:

      public class FatorialRecursivo {
      // Fun√ß√£o recursiva para calcular o fatorial de n
      public static int fatorial(int n) {
        if (n == 0) {
            return 1; // Caso base: 0! √© 1
        } else {
            return n * fatorial(n - 1); // Chamada recursiva
        }
      }

      public static void main(String[] args) {
        int numero = 5;
        int resultado = fatorial(numero);
        System.out.println("O fatorial de " + numero + " √© " + resultado);
      }
      }
  
Explica√ß√£o

Caso Base: Toda fun√ß√£o recursiva precisa de um caso base que termina a recurs√£o. No exemplo, o caso base √© quando n √© 0, retornando 1, pois por defini√ß√£o, 0! √© 1.

Chamada Recursiva: Se n n√£o for 0, a fun√ß√£o chama a si mesma com n - 1. A cada chamada, a fun√ß√£o resolve uma parte do problema at√© alcan√ßar o caso base.


### Fluxo de Execu√ß√£o

Para fatorial(5), o fluxo seria:

fatorial(5) chama fatorial(4)
fatorial(4) chama fatorial(3)
fatorial(3) chama fatorial(2)
fatorial(2) chama fatorial(1)
fatorial(1) chama fatorial(0) (caso base)
fatorial(0) retorna 1

Depois, as chamadas s√£o resolvidas na ordem inversa:

fatorial(1) retorna 1 * 1 = 1
fatorial(2) retorna 2 * 1 = 2
fatorial(3) retorna 3 * 2 = 6
fatorial(4) retorna 4 * 6 = 24
fatorial(5) retorna 5 * 24 = 120

O resultado final √© 120, que √© o fatorial de 5.

Esse √© um exemplo cl√°ssico de recurs√£o em Java. A recurs√£o pode ser muito poderosa, mas deve ser usada com cuidado para evitar problemas como estouro de pilha (stack overflow) quando a profundidade de recurs√£o √© muito grande.


## Recurs√£o com Cauda e Sem cauda


Recurs√£o com cauda e sem cauda s√£o dois tipos de recurs√£o que diferem em como as chamadas recursivas s√£o processadas e otimizadas pelo compilador ou interpretador.

### 1. Recurs√£o Sem Cauda
   
Na recurs√£o sem cauda, a chamada recursiva n√£o √© a √∫ltima opera√ß√£o a ser executada pela fun√ß√£o. Isso significa que o sistema precisa manter na mem√≥ria o estado de cada chamada recursiva at√© que todas as chamadas recursivas sejam resolvidas.

Exemplo: Fatorial Sem Cauda

    public class FatorialSemCauda {
      public static int fatorial(int n) {
        if (n == 0) {
            return 1;
        } else {
            return n * fatorial(n - 1); // A multiplica√ß√£o ocorre ap√≥s a chamada recursiva
        }
      }

    public static void main(String[] args) {
        int resultado = fatorial(5);
        System.out.println("Fatorial sem cauda de 5: " + resultado);
    }
    }

Como Funciona

Cada chamada de fun√ß√£o precisa aguardar o resultado da chamada recursiva subsequente antes de completar a multiplica√ß√£o. Isso significa que a pilha de chamadas de fun√ß√£o cresce at√© que o caso base seja alcan√ßado, e depois come√ßa a ser resolvida na ordem inversa.


### 2. Recurs√£o com Cauda (Tail Recursion)
   
Na recurs√£o com cauda, a chamada recursiva √© a √∫ltima opera√ß√£o executada pela fun√ß√£o. Isso permite que o compilador ou interpretador otimize a recurs√£o, transformando-a em uma itera√ß√£o e evitando o crescimento da pilha de chamadas. Isso √© conhecido como "otimiza√ß√£o de recurs√£o com cauda" ou "tail call optimization".

Exemplo: Fatorial com Cauda

Para implementar a recurs√£o com cauda, geralmente utilizamos um argumento auxiliar para acumular o resultado parcial:

      public class FatorialComCauda {
    // Fun√ß√£o auxiliar que carrega o acumulador
    private static int fatorialTailRec(int n, int acumulador) {
        if (n == 0) {
            return acumulador;
        } else {
            return fatorialTailRec(n - 1, n * acumulador); // A chamada recursiva √© a √∫ltima opera√ß√£o
        }
    }

    // Fun√ß√£o principal que inicia a recurs√£o com cauda
    public static int fatorial(int n) {
        return fatorialTailRec(n, 1); // Come√ßa com acumulador em 1
    }

    public static void main(String[] args) {
        int resultado = fatorial(5);
        System.out.println("Fatorial com cauda de 5: " + resultado);
    }
    }

Como Funciona

Neste caso, a fun√ß√£o fatorialTailRec passa o resultado parcial (acumulador) na chamada recursiva. Como a √∫ltima opera√ß√£o na fun√ß√£o √© a chamada recursiva, o compilador pode otimizar o c√≥digo, reutilizando a mesma estrutura de pilha em vez de criar uma nova para cada chamada. Isso torna a recurs√£o com cauda mais eficiente em termos de mem√≥ria.

### Diferen√ßas e Considera√ß√µes

Efici√™ncia: A recurs√£o com cauda √© mais eficiente em termos de uso de mem√≥ria, pois evita o crescimento da pilha de chamadas. Isso √© especialmente importante em linguagens ou ambientes que suportam otimiza√ß√£o de recurs√£o com cauda.

Legibilidade: A recurs√£o sem cauda √© muitas vezes mais direta e f√°cil de entender, especialmente para problemas simples. No entanto, pode n√£o ser adequada para problemas que envolvem grandes profundidades de recurs√£o.

Otimiza√ß√£o: Nem todas as linguagens e compiladores implementam a otimiza√ß√£o de recurs√£o com cauda, mas muitas linguagens funcionais e modernos compiladores de linguagens como Java e C++ o fazem.

Em resumo, a recurs√£o com cauda √© prefer√≠vel em situa√ß√µes onde a profundidade da recurs√£o pode ser grande, pois ela permite que o compilador otimize a execu√ß√£o, prevenindo problemas de estouro de pilha e melhorando a efici√™ncia geral.












