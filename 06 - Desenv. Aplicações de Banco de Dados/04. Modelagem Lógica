
Modelagem L√≥gica

A modelagem l√≥gica √© um importante passo no projeto de banco de dados. Nesta aula ser√£o abordadas as principais caracter√≠sticas da modelagem l√≥gica e como derivar um modelo conceitual para este. 


CONCEITO DE MODELAGEM L√ìGICA

Chegamos finalmente na modelagem l√≥gica. Considerando as fases do projeto de banco de dados, a modelagem l√≥gica sucede a modelagem conceitual e antecede a √∫ltima fase, a f√≠sica. Nessa fase o artefato gerado √© um modelo l√≥gico e pode-se dizer que ele √© derivado do modelo conceitual.

Antes de come√ßar essa modelagem, √© muito importante entender algumas coisas que ser√£o utilizadas. Primeiro √© preciso relembrar o conceito de entidade e atributo. As entidades representam os objetos do mundo real, enquanto seus atributos representam as caracter√≠sticas destes objetos. Por exemplo, num sistema de e-commerce, voc√™ pode ter a entidade chamada ‚ÄúProduto‚Äù, enquanto seus atributos poss√≠veis podem ser ‚Äúnome‚Äù, ‚Äúfabricante‚Äù, ‚Äúmodelo‚Äù, ‚Äúdescri√ß√£o‚Äù, ‚Äúpre√ßo‚Äù, entre outros.

N√£o podemos esquecer tamb√©m que existem essencialmente dois tipos de atributos: comum (ou tipo ‚Äúdado‚Äù) e identificador (ou tipo ‚Äúchave‚Äù).

O atributo do tipo comum √© aquele que n√£o possui nenhuma restri√ß√£o importante na modelagem conceitual e representa um dado normalmente, daquela entidade. J√° o atributo do tipo chave √© aquele que identifica o conjunto de dados. Em uma tabela um atributo tipo chave n√£o pode ser nulo e nem mesmo se repetir nunca. Por exemplo, no mesmo cen√°rio de um e-commerce, como cada produto possui caracter√≠sticas que podem se repetir, podemos criar um novo atributo chamado ‚Äúid_produto‚Äù para consider√°-lo como chave. Neste caso, este ‚Äúid‚Äù √© √∫nico de um produto (regra de nunca se repetir) e nunca podem existir produtos sem este dado (regra de nunca ser nulo).

‚ÄãPara ilustrar como ficaria a tabela deste exemplo, alguns dados arbitr√°rios e fict√≠cios podem ser vistos na tabela 1. Note que a tabela se chama ‚ÄúProduto‚Äù e cada um dos atributos descritos no modelo conceitual se tornaram as colunas. Note, tamb√©m, que nessa tabela de exemplo os nomes das colunas est√£o todos em letras min√∫sculas e sem quaisquer acentua√ß√µes ou caracteres especiais. Embora seja apenas um exemplo, j√° est√° sendo exibido no padr√£o l√≥gico. Note, tamb√©m, que a coluna ‚Äúid‚Äù possui uma cor diferente para represent√°-la como chave.

Lembre-se que a tabela anterior cont√©m apenas exemplos arbitr√°rios e est√° sendo usada apenas para refer√™ncia. Note uma coisa importante nessa tabela: Cada coluna possui um tipo de dados espec√≠fico. Isso √© algo que devemos prestar bastante aten√ß√£o na hora da modelagem l√≥gica, pois os tipos de dados dependem da tecnologia de banco de dados que ser√° utilizada. √â por isso que durante a modelagem l√≥gica j√° √© preciso saber qual tecnologia de banco de dados ser√° utilizada. Para todos os exemplos a partir de agora, ser√° considerado o Oracle Database como foco e, por isso, toda a modelagem ser√° baseada nele, inclusive realizada com ferramentas da pr√≥pria Oracle, a partir de agora.


TIPOS DE DADOS

No exemplo mostrado anteriormente as colunas possuem tipos espec√≠ficos de dados. Se estiv√©ssemos olhando do ponto de vista de uma linguagem de programa√ß√£o, saber√≠amos que estes atributos s√£o, do tipo: ‚Äúid‚Äù √© um inteiro, ‚Äúnome‚Äù, ‚Äúfabricante‚Äù, ‚Äúmodelo‚Äù e ‚Äúdescricao" s√£o do tipo texto (String para muitas linguagens) e ‚Äúpreco‚Äù do tipo n√∫mero real, ou float (vari√°veis de ponto flutuante) para muitas linguagens. Entretanto, no mundo dos bancos de dados, existem tipos espec√≠ficos para se representar cada tipo em cada tecnologia utilizada. De forma resumida, a tabela 2 mostra os principais tipos de dados em bancos de dados Oracle, mas muito comuns, tamb√©m em outros bancos de dados como, MySQL, MariaDB, SQL Server etc.

    CHAR(n) - Representa uma cadeia de caracteres. Se "n"(tamanho) n√£o for informado, represetar√° apenas um unico caractere. O tamanho maximo √© 2000. Quando um dado n√£o atinge o tamanho maximo uma cadeia de espa√ßoes em branco √© gerado.
    
    VARCHAR2(2) - Representa um texto, onde "n" pode ser de at√© 4000 caracteres. Quando um dado √© inserido sem ocupar o tamanho maximo, o banco de dados acrescenta espa√ßos em branco.

    NUMBER(n) - Representa um numero de at√© "n" digitos. Se o "n" n√£o for informado possuira uma precis√£o de 38 digitos significativos.

    NUMBER(n, d) - Representa um numero decimal de at√© "n" digitos e precis√£o "d", onde "d" √© o numero maximo de casa decimais ap√≥s a virgula.

    DATE - Representa um dado do tipo horas, minutos e segundos, de 1 Jan de 4712 AC at√© 31 de Dez de 9999 DC.

    BLOB - "Binary Large Object", pode armazenar at√© 4GB de texto binario. Normalmente utilizado para arquivos(imagens, videos etc.)

    CLOB - "Character Large Object", por armazenar at√© 4GB de texto.

    BOOLEAN - O Oracle n√£o implementa nativamente o tipo boolean. √â preciso utilizar algum mecanismo como um char(1) ou varchar1(1) ou number(1).


√â muito importante salientar que h√° muitos outros tipos de dados, que ser√£o, neste material, explorados aos poucos e conforme a necessidade. Os tipos de dados mostrados na tabela 2 representam os mais comuns, que podem resolver a maior parte dos casos.

No caso do exemplo da tabela produto, podemos notar que o ‚Äúid‚Äù pode ser do tipo ‚ÄúNUMBER(5)‚Äù, ou seja, um n√∫mero de at√© 5 d√≠gitos enquanto os atributos ‚Äúnome‚Äù pode ser um VARCHAR2(40), ou sejam um texto de at√© quarenta caracteres, o ‚Äúfabricante‚Äù pode ser tipo VARCHAR2(15), o ‚Äúmodelo‚Äù pode ser um VARCHAR2(30), a ‚Äúdescricao" pode ser um VARCHAR2(255) e, finalmente, o atributo ‚Äúpreco‚Äù pode ser um NUMBER(5,2), ou seja um n√∫mero real de at√© 5 d√≠gitos com duas casas decimais de precis√£o.



CHAVE ESTRANGEIRA (FK)

Na modelagem l√≥gica um novo tipo de coluna aparece. As t√£o esperadas chaves estrangeiras ou, em sua nomenclatura original, foreign keys, as famosas FKs. √â muito comum tratarmos esse tipo de coluna com o nome original em ingl√™s ou, simplesmente, pela sigla dela.

As chaves estrangeiras s√£o importantes pois s√£o elas que representar√£o os relacionamentos entre as entidades (que agora come√ßamos a chamar de tabelas). Sempre que estamos derivando o modelo conceitual para o l√≥gico, teremos uma s√©rie de chaves estrangeiras em nosso modelo.

Conceito importante sobre chave estrangeira: Todas as colunas marcadas como ‚ÄúFK‚Äù, sempre apontam para uma coluna de chave prim√°ria (primary key ‚Äì PK), ou seja, os dados que s√£o inseridos dentro das colunas do tipo ‚ÄúFK‚Äù s√£o dados que apontam para outros dados, sempre identificadores (chave) de alguma outra entidade (relacionada) com a tabela que est√° recebendo essa FK. Eventualmente apontam para a mesma tabela, em auto relacionamentos.

Para melhor entendimento, vamos ao exemplo original do ‚Äúproduto‚Äù, mas agora ser√° acrescido uma nova tabela chamada ‚Äúcategoria‚Äù, conforme descrito pelo modelo conceitual da figura 2.

‚ÄãNeste exemplo, fora adicionado uma entidade chamada categoria, onde o produto deve possuir no m√≠nimo uma categoria e no m√°ximo uma categoria, tamb√©m. Por outro lado, a categoria pode n√£o conter nenhum produto, mas tamb√©m pode conter v√°rios produtos. Para o relacionamento em quest√£o, uma FK deve ser gerada na tabela de produto, ou seja, uma nova coluna deve ser inclu√≠da na tabela de produto indicando a qual categoria ele pertence, mas atrav√©s de seu ‚Äúid_categoria‚Äù. Para ilustrar essa ideia, veja a tabela categoria implementada com dados arbitr√°rios.

Note que cada categoria, neste caso, possui um ‚Äúid‚Äù que √© √∫nico da categoria e, para satisfazer esse tipo de relacionamento, o ‚Äúid_categoria‚Äù deve ser adicionado na tabela de produtos, conforme exemplificado com dados arbitr√°rios da tabela 4. Isso quer dizer que a ‚Äúid_categoria‚Äù na tabela de produtos √© um FK para tabela ‚ÄúCategoria‚Äù. Neste modelo foi adicionada a FK na tabela ‚Äúprotudo‚Äù pois cada produto possui uma categoria, ou seja, o entendimento do contexto tamb√©m √© necess√°rio para a inclus√£o dessa FK no local correto e indicada pela modelagem l√≥gica, vista a seguir.



MODELAGEM L√ìGICA

Uma vez compreendidos os principais conceitos da modelagem l√≥gica, os tipos de dados e os tipos de colunas (chave, dado e chave estrangeira), podemos finalmente come√ßar a criar a modelagem l√≥gica, que possui uma nota√ß√£o bastante simples, mas regras importantes de deriva√ß√£o do modelo conceitual, apresentadas posteriormente.

A modelagem l√≥gica √© composta por um diagrama onde cada entidade √© representada por um ret√¢ngulo dividido em at√© quatro partes, horizontalmente. Na primeira parte (superior) coloca-se o nome da tabela (ou entidade). Na segunda parte coloca-se os atributos indicando-se os tipos ao lado direito, na terceira parte os atributos chaves e na quarta parte os atributos que s√£o chaves estrangeiras.

A figura 3 mostra o diagrama do exemplo desta aula criado utilizando o software ‚ÄúOracle SQL Developer Data Modeler‚Äù que √© gratuito e bastante completo. √â muito comum se utilizar softwares diferentes para a modelagem l√≥gica e se obter resultados distintos ao mostrado abaixo, mas o importante √© que todos ir√£o representar as entidades de forma muito similar. Outros softwares que tamb√©m realizam a modelagem l√≥gica s√£o o brModelo, Astah Professional (pago), StarUML (gratuito para testar), MySQLworkbench (para MySQL), site draw.io (online), site sqldbm.com (online e ainda n√£o dispon√≠vel para Oracle, embora em processo de atualiza√ß√£o), entre muitos outros.

Note neste diagrama algumas peculiaridades. Na tabela de ‚ÄúProduto‚Äù, em frente ao atributo ‚Äúid‚Äù h√° um ‚ÄúP‚Äù que indica que este √© um atributo chave (primary key) em frente ao ‚Äúid_categoria‚Äù h√° um ‚ÄúF‚Äù, que indica que este √© um atributo do tipo ‚Äúforeign key‚Äù, que aponta pra a entidade ‚ÄúCartegoria‚Äù. No caso dos bancos e dados Oracle, as FKs recebem um registro, chamado de ‚Äúconstraint‚Äù no banco e elas recebem um nome. Neste caso esse relacionamento foi chamado de ‚ÄúProduto_Categoria_FK‚Äù e est√° aplicada √† coluna ‚Äúid_categoria‚Äù. O pequeno asterisco (*) vermelho em frente √† cada um dos atributos indica que eles n√£o podem ser nulos, ou seja, s√£o campos obrigat√≥rios. Isso, em frente ao ‚Äúid_categoria‚Äù da tabela ‚ÄúProduto‚Äù garante a cardinalidade m√≠nima de 1, ou seja, todo produto obrigatoriamente deve conter uma categoria.



ABORDAGENS DE AN√ÅLISE DOS MODELOS

A modelagem dos dados n√£o √© tarefa executada numa √∫nica itera√ß√£o devido a sua natura e complexidade. Ela precisa ser feita gradativamente e, a cada etapa, s√£o acrescidos novos itens aos j√° existentes, tornado o modelo gradativamente melhor. Na pr√°tica nenhuma das estrat√©gias de an√°lise e propostas na literatura √© aceita de forma universal. Normalmente usamos constru√ß√£o dos modelos considerando tr√™s poss√≠veis abordagens (ou metodologias) de modelagem de dados. (HEUSER, 2004).

Podemos realizar a modelagem dos dados atrav√©s de v√°rias fontes, como por exemplo a descri√ß√£o textual de dados preexistentes (que j√° existem) ou de conhecimentos do mundo real modelado, relatado verbalmente pelos envolvidos no projeto. Neste caso, ent√£o usamos a engenharia reversa, tamb√©m chamada de abordagem bottom-up (baixo para cima). Nesta abordagem iniciamos a modelagem utilizando tabelas e dados existentes e formatados em um banco de dados, apenas os adaptando at√© a modelagem conceitual.

Quando utilizamos a an√°lise de requisitos do dom√≠nio (contexto) da aplica√ß√£o, ou seja, o projeto modelado √© desenvolvido a partir do que se conhece sobre o dom√≠nio modelado, podemos utilizar duas poss√≠veis estrat√©gias: top-down (cima para baixo) ou, ainda, o inside-up (dentro para fora) (HEUSER, 2004).

Na metodologia top-down, partimos da an√°lise de requisitos para identificarmos as entidades do mundo real e criamos primeiro a modelagem conceitual, definimos os relacionamentos e suas respectivas cardinalidades. Em seguida, podemos realizar alguns testes de valida√ß√£o com dados fict√≠cios que simulam a realidade e o usu√°rio do banco pode, inclusive, participar deste processo.

J√° na metodologia inside-up partimos de uma ideia centralizadora (central) onde definimos as principais entidades que fazem parte do mundo real e, em seguida, s√£o inclu√≠das ao centro do modelo. A partir dele, come√ßamos a realizar os detalhamentos, ampliando gradativamente os relacionamentos, identificando as cardinalidades etc., como fazemos no processo top-down. Em uma primeira etapa, desenhamos o modelo conceitual com seus respectivos relacionamentos e cardinalidades, eventuais generaliza√ß√µes e especializa√ß√µes. Depois disso, definimos cuidadosamente os atributos comuns. Finalmente, na √∫ltima etapa, realizamos os testes de valida√ß√£o, com dados arbitr√°rios e onde o usu√°rio final pode participar tamb√©m.

Entender essas abordagens pode nos ajudar a entender qual a melhor forma de aprender o processo de deriva√ß√£o, pois cada pessoa √© √∫nica e possui suas prefer√™ncias de aprendizagem. Para as regras de deriva√ß√£o, ser√£o apresentadas as modelagens e as tabelas resultantes de forma generalista, para entendimento de como os dados ficariam em tabelas reais. Podemos considerar que √© como uma engenharia reversa.



A CARDINALIDADE E OS RELACIONAMENTOS NO MODELO L√ìGICO

Para as regras de deriva√ß√£o o entendimento de cardinalidade do modelo conceitual deve estar muito bem fixado e, apesar deste assunto j√° ter sido tratado anteriormente, √© muito importante refor√ß√°-lo, pois a deriva√ß√£o do modelo conceitual em l√≥gico depende quase que exclusivamente das cardinalidades.

Na modelagem conceitual a cardinalidade pode ser dada por quantos elementos de uma entidade referem-se √† outra entidade. Toda entidade que se relaciona com outra deve ter uma cardinalidade e, aqui, √© representada em m√≠nimo e m√°ximo. A cardinalidade na modelagem conceitual sempre deve ser representada conforme a figura 1, ou seja, um par√™ntese, a cardinalidade m√≠nima, uma ‚Äúv√≠rgula‚Äù, a cardinalidade m√°xima e o par√™ntese de fechamento.

A cardinalidade m√≠nima pode ser 0 (zero) ou 1 (um) e representa a obrigatoriedade de uma entidade em rela√ß√£o √† outra, enquanto a cardinalidade m√°xima pode ser 1 (um) ou N (‚Äúene‚Äù), portanto as possibilidades s√£o:

    I. (0, 1) ü°™ Indica que a entidade pode ter nenhum ou apenas um de outra

    II. (0, n) ü°™Indica que a entidade pode ter nenhum ou v√°rios (mais de 1) de outra

    III. (1, 1) ü°™ Indica que a entidade precisa ter ao menos um e n√£o mais que isso

    IV. (1, n) ü°™ Indica que a entidade precisa ter ao menos um e no m√°ximo v√°rios


Na modelagem conceitual a cardinalidade vai sempre do lado de cada entidade e representa o quanto de uma entidade e refletida na outra. Por exemplo, veja o modelo conceitual gen√©rico denotado pela figura 2. Neste exemplo arbitr√°rio pode-se reconhecer as cardinalidades da seguinte forma: A ‚ÄúEntidade A‚Äù possui ao menos um e no m√°ximo um de ‚ÄúEntidade B‚Äù e, por outro lado, a ‚ÄúEntidade B‚Äù, possui um ou v√°rios da ‚ÄúEntidade A‚Äù.

Cada par de cardinalidade possui uma regra de deriva√ß√£o espec√≠fica e, para o fazer, √© preciso relembrar, tamb√©m o conceito de chave estrangeira, FK.

As chaves estrangeiras s√£o importantes pois s√£o elas que representar√£o os relacionamentos entre as entidades (que agora come√ßaremos a chamar de tabelas). Sempre que estamos derivando o modelo conceitual para o l√≥gico, teremos uma s√©rie de chaves estrangeiras em nosso modelo.

Conceito importante sobre chave estrangeira: Todas as colunas marcadas como ‚ÄúFK‚Äù, sempre apontam para uma coluna de chave prim√°ria (primary key ‚Äì PK), ou seja, os dados que s√£o inseridos dentro das colunas do tipo ‚ÄúFK‚Äù s√£o dados que apontam para outros dados, sempre identificadores (chave) de alguma outra entidade (relacionada) com a tabela que est√° recebendo essa FK ou, da pr√≥pria tabela, em casos de auto relacionamento.

Este conceito √© muito importante pois as cardinalidades influenciar√£o diretamente em onde as FKs ser√£o colocadas na modelagem l√≥gica e √© exatamente isso que descrevem as regras de deriva√ß√£o.



CHAVES √öNICAS E N√ÉO NULAS

Antes de apresentarmos como √© realizada a deriva√ß√£o do modelo conceitual para o l√≥gico, vamos aprender sobre alguns conceitos muito importantes utilizados em bancos de dados relacionais.

A chave prim√°ria (Primary Key ‚Äì PK) n√≥s j√° aprendemos e podemos considerar que s√£o as que identificam um determinado registro, ou seja, os dados n√£o podem ser repetir (devem ser √∫nicos) e nunca podem ser nulos. Por exemplo, o CPF de uma pessoa, o registro acad√™mico de um aluno, o ISBN de um livro, o CRM de um m√©dico etc. Quando a entidade n√£o possui um atributo que possa ser considerado identificador, n√≥s podemos definir um e normalmente o fazemos com o nome ‚Äúid‚Äù (de identificador).

Temos, agora, que entender um novo conceito o da chave n√£o nula, ou seja, a chave que chamamos de ‚ÄúNOT NULL‚Äù. A chave n√£o nula √© aquela cujo dado nunca pode ser vazio, mas n√£o confunda com a chave prim√°ria. Aqui os dados podem se repetir. Por exemplo, quando h√° uma cardinalidade m√≠nima de 1, obrigatoriamente o dado precisar√° estar presente. Para ilustrar este conceito, pense na rela√ß√£o de autor e livro. Um livro sempre precisar√° de um autor, ent√£o a chave dessa rela√ß√£o sempre precisa ser ‚Äún√£o nula‚Äù ou, simplesmente, ‚ÄúNOT NULL‚Äù.

Existe agora uma quarta chave importante: a chave √∫nica ou, chamada simplesmente de ‚ÄúUNIQUE‚Äù. Essa chave √© utilizada quando determinado dado em uma coluna n√£o pode se repetir, mas ao mesmo tempo ele n√£o √© chave. A restri√ß√£o UNIQUE n√£o √© chave prim√°ria. Por exemplo, o e-mail de um usu√°rio no sistema. O e-mail normalmente n√£o √© identificador em uma base de dados, mas tamb√©m n√£o pode se repetir em usu√°rios diferentes.

Podemos considerar, ainda que a PK √© uma chave que √© ao mesmo tempo ‚ÄúUNIQUE‚Äù e ‚ÄúNOT NULL‚Äù, para melhorar o entendimento. Podemos agora partir para a deriva√ß√£o da modelagem conceitual.



REGRAS DE DERIVA√á√ÉO

Podemos classificar os relacionamentos quando aos tipos, baseado em suas cardinalidades. H√°, essencialmente sete tipos, embora diferentes autores da √°rea definem isso de formas distintas. Relacionamentos bin√°rios 1:1, bin√°rios N:N, relacionamentos com atributo identificados, relacionamentos tern√°rios, auto relacionamento 1:1, auto relacionamento 1:N e auto relacionamento N:N. Alguns autores dizem que h√° apenas tr√™s (um para um, um para muitos e muitos para muitos), mas vamos explorar da forma mais completa poss√≠vel este conceito.

Para ilustrar este conceituo ser√£o apresentadas as modelagens poss√≠veis e suas respectivas tabelas de exemplo e suas modelagens l√≥gicas. Isso tamb√©m ajudar√° muito no entendimento do processo de deriva√ß√£o dos modelos. A tabela 1 mostra como o significa das abrevia√ß√µes que ser√£o utilizadas aqui.

    ABREVIA√á√ÉO    |  EXPLICA√á√ÉO
    A, B, C       | Entidades e Tablelas
    X, Y, W       | Atributos nas entidades chaves primarias/estrangeiras
    PK            | Primary Key (chave primaria)
    FK            | Foreign Key (chave estrangeira)


Baseado nisso, podemos come√ßar a derivar os modelos e isso ser√° feito com exemplos, para melhor entendimento das regras de deriva√ß√£o



Relacionamentos bin√°rios 1:1:

 Estes s√£o os relacionamentos cuja cardinalidade m√°xima sempre √© ‚Äú1‚Äù. A figura 3 ilustra esses relacionamentos as suas respectivas deriva√ß√µes. Para relacionamentos deste contexto, podemos considerar que as regras s√£o:

    I.   A (1, 1) <-> (1, 1) B √† 1 para 1 em ambos os lados sempre deve gerar a jun√ß√£o das tabelas

    II.   A (0, 1)  <-> (1, 1) B √† Tabela A recebe a FK que aponta para B. Essa FK n√£o pode ser nula

    III.   A (1, 1)  <-> (0, 1) B √† Tabela B recebe a FK que aponta para A. Essa FK n√£o pode ser nula

    IV.   A (0, 1)  <-> (0, 1) B √† Neste caso √© indiferente qual das tabelas receber√° a FK. Apenas uma deve receber e n√£o h√° restri√ß√£o de nulidade.


Relacionamentos bin√°rios 1:N:

 Estes relacionamentos s√£o aqueles cuja cardinalidade m√°xima em um dos lados √© ‚Äú1‚Äù e do outro lado √© ‚ÄúN‚Äù, variando apenas a cardinalidade m√≠nima. A figura 4 ilustra esses relacionamentos as suas respectivas deriva√ß√µes nas modelagens. Para este relacionamento, a entidade que est√° do mesmo lado que o ‚ÄúN‚Äù, sempre receber√° a FK. Para relacionamentos deste contexto, podemos considerar que as regras s√£o:

    I.    A(1, 1) <-> (1, N) B √† A tabela B recebe a FK que n√£o pode ser nula

    II.   A(1, 1) <-> (0, N) B √† A tabela B recebe a FK que n√£o pode ser nula

    III.   A(0, 1) <-> (1, N) B √† A tabela B recebe a FK que pode ser nula

    IV.   A(0, 1) <-> (0, N) B √† A tabela B recebe a FK que pode ser nula


Note que nas rela√ß√µes (1, N) e (0, N) as deriva√ß√µes s√£o iguais e, portanto, podemos considerar que essas rela√ß√µes quando ocorrem s√£o indiferentes para a modelagem l√≥gica, mas muito importantes para a modelagem conceitual.


Relacionamentos bin√°rios N:N: 

    Estes relacionamentos ocorrem quando a cardinalidade m√°xima √© ‚ÄúN‚Äù (v√°rios) de ambos os lados. Neste caso, sempre √© gerada uma tabela nova entre as entidades, chamada de tabela de relacionamento. Essas tabelas de relacionamento no modelo conceitual s√£o as entidades associativas que podem ou n√£o ter atributos de relacionamento (com atributos ser√£o apresentados a seguir), ou seja, podem expressar mais detalhes do relacionamento na pr√≥pria associa√ß√£o. A figura 5 exemplifica isso de forma gen√©rica para a deriva√ß√£o (1, N) de ambos os lados. Para as cardinalidades m√≠nimas, basta retirar a obrigatoriedade do campo na tabela de relacionamento. As regras de deriva√ß√£o podem ser descritas como:

        I.   A(1, N) <-> (1, N)B √† Gerada uma tabela de relacionamento onde ambos as FKs s√£o ‚Äún√£o nulas

        II.  A(1, N) <-> (0, N)B √† Gerada uma tabela de relacionamento. A FKs que aponta para a tabela B deve ser ‚Äún√£o nula‚Äù

        III. A(0, N) <-> (1, N)B √† Gerada uma tabela de relacionamento. A FKs que aponta para a tabela A deve ser ‚Äún√£o nula‚Äù

        IV.  A(0, N) <-> (0, N)B √† Gerada uma tabela de relacionamento. Ambas as FKs n√£o precisam da obrigatoriedade, ou seja, podem ser nulas


Relacionamentos bin√°rios N:N com dados: 
    
    Ocorrem quando h√° uma rela√ß√£o ‚ÄúN‚Äù de ambos os lados e na rela√ß√£o h√° dados que podem ou n√£o ser identificadores. Da mesma forma que os relacionamentos ‚ÄúN para N‚Äù, √© gerada uma tabela de relacionamento, mas com uma coluna a mais, representando os atributos da rela√ß√£o, conforme pode ser observado na figura 6. Lembre-se que para isso, na modelagem conceitual o relacionamento torna-se uma entidade associativa.

     
Autorelacionamento 1:1 ou 1:N :

 Neste caso, quando uma entidade se relaciona com ela mesma chamamos de autorelacionamento. A √∫nica diferen√ßa entre o auto relacionamento 1:1: e 1:N √© que no caso da 1:1 a FK dever ser √∫nica, ou seja, ‚ÄúUNIQUE‚Äù, conforme descrito anteriormente. A figura 7 mostra ambos os exemplos. Um exemplo bastante comum de autorelacionamento √© o ‚Äúcasamento‚Äù ou a lota√ß√£o de um departamento, sobre a perspectiva de hierarquia. O exemplo da figura 7 mostra a deriva√ß√£o com dados destes exemplos.


Provavelmente voc√™ deve estar se perguntando: Nossa, quantas regras. Precisarei decorar tudo isso? A resposta √© simples. N√£o, n√£o √© necess√°rio, pois uma vez compreendidas as modelagens, voc√™ saber√° realizar as deriva√ß√µes rapidamente, sem ter de ficar consultando todas essas regras. Elas s√£o apresentadas pois fazem parte do processo de ensino e devem sim ser formalizadas. Al√©m do mais, voc√™ se acostumar√°, de tanto usar. Lembre-se, tamb√©m, que a ideia da engenharia reversa, ou seja, pensar em como as tabelas ficariam fisicamente, pode ajudar bastante no processo. Por isso as tabelas resultantes s√£o apresentadas, apesar de n√£o fazerem parte da modelagem de dados.



Atividade extra

Tente pegar um jogo, um aplicativo ou programa que voc√™ utiliza muito e criar a modelagem conceitual dele e, em seguida, demonstrar as tabelas que podem ser geradas e sua respectiva modelagem l√≥gica.



Refer√™ncia Bibliogr√°fica

DATE, C. J. Introdu√ß√£o a sistemas de banco de dados. Rio de Janeiro. Ed. Campus, 1991.
CHEN, Peter. Modelagem de dados: a abordagem entidade-relacionamento para projeto l√≥gico. S√£o Paulo: Makron Books, 1990.
MEDEIROS, L. F., Banco de dados, princ√≠pios e pr√°ticas, 1¬™. ed., Ed. Intersaberes, 2013
PUGA, S., Fran√ßa E., GOYA M., Banco de dados: Implementa√ß√£o em SQL, PL/SQL e Oracle 11g, Ed. Pearson, 2013
ELMASRI R., NAVATHE, S., Sistemas de Banco de Dados, 4¬™ed., Ed. Pearson, 2005