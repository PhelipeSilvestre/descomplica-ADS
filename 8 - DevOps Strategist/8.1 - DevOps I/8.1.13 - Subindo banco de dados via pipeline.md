## Subindo banco de dados via pipeline

Muito bem! Chegamos ao momento mágico de finalmente criarmos nossas pipelines apartadas (fora do repositório de teste) para subirmos nossa solução por completo!

Iremos começar com os bancos de dados, temos 2 para subirmos: Oracle e MySQL.

Vamos começar com o MySQL pois ele é menor e versátil para fins de aprendizado.

No Gitlab, crie um repositório novo, pode ser um projeto em branco mesmo, se possível com o nome “mysql” caso você já não tenha utilizado este nome de projeto no seu repositório (caso contrário escolha outro nome de projeto). Importante você criar isso no **SEU** repositório hein!

Você pode opcionalmente descrever o que será seu repositório, no campo “Project deployment target (optional) não precisa alterar nada e no campo “Visibility Level” pode manter a opção “Private” mesmo (à não ser que você queira deixar seu repositório público, por sua conta e risco). Também pode manter checada a opção “Initialize repository with a README” e clique em “Create project”.

Faça o git clone para a sua máquina, pois traremos algumas coisas já pré-prontas!

Usaremos o script\_inicial.sql e o script\_tabelas.sql após subir nosso container pela primeira vez!

Eu sei que subimos lá atrás um banco de dados MySQL, mas faremos tudo do zero aqui via pipeline, então vá no Docker Desktop e **exclua** o container que criamos chamado “MeuMySQL”. A imagem do mysql:latest você poderá manter, se você excluir a única diferença é que haverá o download da imagem quando subirmos o pipeline, se a imagem já estiver lá pulamos esta etapa, aí é com você a decisão de excluir a imagem ou manter! Como estamos zerando tudo, se você fez como eu a criação de um volume, delete todo o conteúdo do volume para criarmos do zero mesmo! No meu caso eu excluí todo o conteúdo da pasta D:\\docker\\volumes\\mysql que é a que existe no meu computador.

Vamos lembrar de uma coisa muito importante, o comando que usamos para subir o container:

docker run --name MeuMySQL --network MinhaRede -v /D/docker/volumes/mysql:/var/lib/mysql -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=Minha@senha -e MYSQL\_USER=MeuUsuario -e MYSQL\_PASSWORD=MinhaSenha -d mysql:latest

Tem algumas informações que não são muito legais mantermos aberto no script de pipeline de nosso repositório, veremos mais à frente como guardar isso no Gitlab para não precisarmos deixar explícito assim no script, por enquanto apenas tome nota.

Pronto! Temos um repositório preparado, agora vamos para o outro:

Faça a criação de outro repositório (sim, tem que estar separado, pois só pode haver 1 pipeline, ou seja 1 .gitlab-ci.yml, por repositório), agora chamado de oracle (veja se você já não possui um projeto com este nome em seu repositório, se tiver escolha outro nome). Importante você criar isso no **SEU** repositório hein!

Faça o git clone para a sua máquina, pois traremos algumas coisas já pré-prontas igual fizemos com o MySQL!

Teremos que fazer a cópia de um arquivo que está no repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica), na pasta cicd\_database\\oracle, somente o arquivo script\_inicial.sql. Crie uma pasta chamada setup no diretório do Windows você criou para o oracle e coloque esse arquivo script\_inicial.sql dentro dessa pasta setup, no meu caso está em D:\\docker\\volumes\\oracle\\setup. Isso será necessário para configurarmos o volume em que o container lerá o script inicial.

Eu sei que subimos lá atrás um banco de dados Oracle também, mas faremos tudo do zero aqui via pipeline, então vá no Docker Desktop e **exclua** o container que criamos chamado “MeuOracle”. A imagem do oracle/database:18.4.0-xe você **não poderá manter**, lembre que no caso do Oracle nós fizemos o build de uma imagem e aqui teremos que fazer novamente, então **exclua também a imagem**! Como estamos zerando tudo, se você fez como eu a criação de um volume, delete todo o conteúdo do volume para criarmos do zero mesmo! No meu caso eu excluí todo o conteúdo da pasta D:\\docker\\volumes\\oracle que é a que existe no meu computador.

Vamos lembrar de outra coisa muito importante, o comando que usamos para subir o container:

docker run --name MeuOracle --network MinhaRede -v /D/docker/volumes/oracle/oradata:/opt/oracle/oradata -v /D/docker/volumes/oracle/setup:/opt/oracle/scripts/setup -p 1521:1521 -p 5500:5500 -e ORACLE\_PWD=MinhaSenha -e ORACLE\_CHARACTERSET=AL32UTF8 -d oracle/database:18.4.0-xe

Também é uma informação que não é muito legal mantermos aberto no script de pipeline de nosso repositório assim como no exemplo do MySQL, veremos mais à frente como guardar isso no Gitlab para não precisarmos deixar explícito assim no script, lembre-se das duas anotações, a do MySQL e a do Oracle a respeito de senhas!

Tem algumas maneiras de se gravarem o que chamamos de Secrets (segredos), na documentação de referência tem até instruções para uso de fontes externas de gestão de senhas ([https://docs.gitlab.com/ee/ci/secrets/](https://docs.gitlab.com/ee/ci/secrets/)), mas aqui faremos algo um pouco mais simples, até porque criar um cofre externo neste caso não seria muito didático, o importante aqui é saber que é possível não expor senhas de forma aberta.

Para isso você terá que ir em cada repositório e criar algumas variáveis do Gitlab, vamos fazer primeiro no repositório do MySQL.

No repositório do MySQL, vá no menu lateral à esquerda no item “Settings” e depois clique em “CI/CD”.

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829074645-bOyLkn6n9A.png)

​Clique no botão “Expand” na guia “Variables”.​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829094464-PiWGTl7spf.png)

​Clique no botão “Add Variable”, vamos criar algumas variáveis para o usuário root do MySQL, o usuário “normal” e a senha do usuário “normal”.​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829117954-EweB3kdMeG.png)

​Neste primeiro momento vamos criar uma variável chamada mysqlrootpassword com o valor Minha@senha, marque a opção “Mask variable”, o restante deixe o padrão. Depois clique no botão “Add variable”.​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829138964-2Ij7femtrM.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829152143-IwGkfIrLO3.png)

Faça o mesmo procedimento para criar mais 2 variáveis, com a opção de mascaramento também:

Variável mysqluser, valor MeuUsuario

Variável mysqluserpassword, valor MinhaSenha

Ao final deverá ficar algo assim:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829179804-TQ94oSnaIc.png)

No repositório do Oracle vamos fazer a mesma coisa, criando a seguinte variável:

Variável oraclesyspassword, valor MinhaSenha

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829207824-NjVMho8E37.png)

​Agora vamos voltar ao repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica) para olharmos o script .gitlab-ci.yml da pasta cicd\_database\\mysql\\01-Before\_After\_script.​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1684876219591-VMWF5Wm37C.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1684876304478-7QrHDYZ2Tp.png)

Aqui a novidade é o before\_script e o after\_script. Do jeito que foram declarados, estão como algo geral em todo o script de pipeline.

O que estiver no before\_script será executado em todos os jobs antes do que estiver em **script**.

E o que estiver no after\_script será executado em todos os jobs depois do que estiver em **script**.

Se você colocar tanto o before\_script ou o after\_script dentro de um job, o que estiver dentro do job irá sobrepor o before e after geral.

Este script tem um conjunto de verificações, se o container existir e estiver rodando nada será feito, se o container não estiver rodando mas existir então o script tentará iniciar o container, agora se o container não existir então será feita a tentativa de criar o container.

Agora vamos voltar ao repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica) para olharmos o script .gitlab-ci.yml da pasta cicd\_database\\mysql\\02-Ony\_Except\_script.

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1684876398290-jpQKvD60qf.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1684876427161-HoEdoGgLEn.png)

​Vejamos a sintaxe do only:​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829260763-5hCcJLPzdv.png)

Ao indicar a instrução only no job, indicamos que o job só poderá ser executado sob as circunstâncias indicadas no only, no nosso caso somente quando houver uma alteração em uma branch iniciada com “release\_x.y”, onde x e y são números, ou seja, se criarmos uma branch chamada release\_1.0, o pipeline será iniciado para execução do job “Implantacao\_MySQL”.

Agora vamos ver o except:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678829277718-rN87ENtGX3.png)

Aqui a intenção é oposta, o job com a instrução except sempre executará exceto sob a circunstância indicada no except, no nosso caso quando houver uma alteração na branch main, o job não será executado.

Agora vamos voltar ao repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica) para olharmos o script .gitlab-ci.yml da pasta cicd\_database\\oracle.

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1684876559791-KfUBXVgwgD.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1684876587227-rDTgHiTNeU.png)

Aqui a diferença em relação ao script do MySQL é a adição de um **stage** de build, uma vez que a imagem não está disponível publicamente e teremos que efetuar o build da imagem do Oracle antes de tentar criar um container.

Muito bem, vamos subir os 2 scripts em seus respectivos repositórios!

No seu repositório do MySQL coloque uma cópia do arquivo .gitlab-ci.yml que se encontra no repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica), na pasta cicd\_database\\mysql.

No seu repositório do Oracle coloque uma cópia do arquivo .gitlab-ci.yml que se encontra no repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica), na pasta cicd\_database\\oracle.

Em ambos os repositórios, vá no menu lateral à esquerda em Settings e depois clique em CI/CD.

Clique no botão “Expand” na guia “Runners”.

Aquele runner que utilizamos no repositório de testes aparecerá, mas você precisa clicar no botão “Enable for this project” para habilitar aquele nosso runner para executar as pipelines, faça isso nos 2 repositórios (do MySQL e do Oracle).

Como a criação da imagem do Oracle demora bastante, sugiro você clicar no botão “Expand” da guia “General pipelines” (ainda em Settings -> CI/CD) para aumentar o valor do campo “Timeout” de “1h” para “2h”, significa que o tempo total de 2 horas será concedido à execução da pipeline, caso atinja as 2h e a pipeline não consiga ser executada por completo, a pipeline falhará.

Pronto! Agora sua pipeline está pronta para criar os 2 containers, como configuramos via only e except para rodar os jobs somente por uma branch que comece com “release”, você poderá criar uma branch chamada “release\_1.0” (sem as aspas duplas) tomando como base a branch main, assim que você fizer isso sua pipeline se iniciará!

**Observação importante:** como indicamos nas variáveis que criamos (as secrets) que elas só poderiam ser utilizadas em branches protegidas ou com tags, você terá que proteger essas branches chamadas releases que criar! Assim que criar, vá no menu lateral “Settings” e clique em “Repository”, clique no botão “Expand” na guia “Protected branches” e selecione a branch de release que criou para protege-la, marcando as opções “Allowed to merge” com a opção “Developers + Maintainers” (ou só “Maintainers”) e a opção “Allowed to push” como “None” (forçando ter que fazer merge request de outra branch para esta).

Caso você venha a fazer modificações, você poderá criar outras branches (por exemplo release\_1.1) ou criar novas branches à partir da main. O importante é que a pipeline só será iniciada à partir dessas branches que começam com “release\_” ao invés de iniciarem com a branch main.

Você poderá configurar sua pipeline para mudar isso, caso deseje.

**Atividade Extra**

Para se aprofundar no assunto desta aula leia o documento de referência: “Mask a CI/CD variable”.

Neste documento há as regras para permitir o mascaramento de valores de variáveis.

Link do documento: [https://docs.gitlab.com/ee/ci/variables/index.html#mask-a-cicd-variable](https://docs.gitlab.com/ee/ci/variables/index.html#mask-a-cicd-variable)

No documento de referência “.gitlab-ci.yml keyword reference” você encontra um pouco mais de detalhes sobre o before\_script e after\_script.

Link do documento: [https://docs.gitlab.com/ee/ci/yaml/](https://docs.gitlab.com/ee/ci/yaml/)

No documento de referência “Choose when to run Jobs” você encontra opções adicionais ao only e except.

Link do documento: [https://docs.gitlab.com/ee/ci/jobs/job\_control.html](https://docs.gitlab.com/ee/ci/jobs/job_control.html)

 

 

**Referência Bibliográfica**

- OGURA, Everton J. Repositório do GitLab, projeto Descomplica. Disponível em [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica). Acesso em 17 de junho de 2022.
- SCHKN. Bash If Else Syntax With Examples. Disponível em [https://devconnected.com/bash-if-else-syntax-with-examples/](https://devconnected.com/bash-if-else-syntax-with-examples/). Acesso em 17 de junho de 2022

- .gitlab-ci.yml keyword reference. Disponível em [https://docs.gitlab.com/ee/ci/yaml/](https://docs.gitlab.com/ee/ci/yaml/). Acesso em 17 de junho de 2022
- Secrets. Disponível em [https://docs.gitlab.com/charts/installation/secrets.html](https://docs.gitlab.com/charts/installation/secrets.html). Acesso em 17 de junho de 2022.
- Using external secrets in CI. Disponível em [https://docs.gitlab.com/ee/ci/secrets/](https://docs.gitlab.com/ee/ci/secrets/). Acesso em 17 de junho de 2022.
- docker start. Disponível em [https://docs.docker.com/engine/reference/commandline/start/](https://docs.docker.com/engine/reference/commandline/start/). Acesso em 17 de junho de 2022
- Choose when to run Jobs. Disponível em [https://docs.gitlab.com/ee/ci/jobs/job\_control.html](https://docs.gitlab.com/ee/ci/jobs/job_control.html). Acesso em 17 de junho de 2022