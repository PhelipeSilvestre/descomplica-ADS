## Ambientes

Depois que subimos nossa solução de ponta-a-ponta, vamos agora olhar para o todo só que com outra perspectiva.

Imagine que você estivesse trabalhando com uma solução como esta em uma empresa, só que você tem coleguinhas trabalhando em conjunto no mesmo repositório (sim, isso é comum). Como é que você faria para organizar o que você está fazendo sem atrapalhar o coleguinha?

É aí que vem as branches do Gitlab.

As branches (galhos em tradução livre) são como se fossem cópias do que estiver no repositório para que várias pessoas consigam trabalhar de forma colaborativa, em paralelo.

Isso significa que eu teria uma branch para que eu consiga trabalhar e você teria uma outra branch (diferente da minha) para que você trabalhe. Ao final nós faríamos o que chamamos de merge (mesclagem) do que produzimos para termos uma única solução.

Até agora nós brincamos apenas com 2 branches: a main (que o repositório já cria automaticamente) e a Release (que nós criamos para testar os fluxos da pipeline), mas podemos organizar de outras formas.

Pensando no dia-a-dia de trabalho, o mais comum é vermos uma organização de branches como à seguir:

- Main / Master / Prod / Production / Produção: geralmente essas nomenclaturas de branches representam o código que vai para produção, é onde o negócio da empresa disponibiliza seus serviços aos clientes/parceiros.
- Staging / QA / Hom / Homologation / Homologação: geralmente essas nomenclaturas de branches representam o código que vai para homologação, para ser testado pelo time de qualidade ou por um time de negócios, antes de ir para o ambiente de produção.
- Release / Dev / Development / Desenvolvimento: geralmente essas nomenclaturas de branches representam o código que vai para um ambiente de desenvolvimento, para testes do desenvolvedor antes de ir para os testes de QA ou negócios.
- Feature: geralmente essa nomenclatura de branch representa o código que é cópia da branch de desenvolvimento só que específico para algo que alguém esteja trabalhando, é onde o desenvolvedor faz o clone e trabalha.
- Emergency / HotFix: geralmente essas nomenclaturas de branches representam o código que está em ambiente de produção, só que ao identificar um problema geralmente acompanhado de um incidente, é indicado para que se pule outras etapas (como homologação) a fim de restabelecer o ambiente produtivo à sua normalidade.

A organização do repositório em várias branches até aqui não impacta em nada a pipeline, mas podemos usar um atributo especial chamado “Environment” no nosso script.

No repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica), na pasta cicd\_frontend -> 02-Environment tem o script com uma pequena adição, ao final:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914310193-vyJkuRjFo4.png)

​Veja que incluímos esse trecho aqui:​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914321638-JWSKADGvqm.png)

​Ao subir esse código e fazer o merge request para a branch releas\_1.0, além do pipeline iniciar você pode acompanhar também o deploy (a implantação) no Gitlab, menu à esquerda “Deployments” e depois clique no item “Environments”.​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914334960-iG1P2ga30K.png)

O “Environment” é apenas uma forma de organizar as execuções das pipelines, você terá uma visão das implantações que você fez (no nosso caso, indicamos que o ambiente é o de release e que somente o job Criar\_Container da stage de “deploy” é que aparecerá aqui), é uma maneira de você acompanhar o que aconteceu em cada ambiente que a pipeline entregou.

Veja como fica esta informação assim que o deploy é finalizado:

  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914349381-NhXOtHMVLu.png)

Então além de podermos acompanhar as execuções na tela das Pipelines, uma outra opção é esta em que podemos acompanhar as implantações por ambiente.

Agora vamos falar especificamente da Release branch. Nós estamos utilizando esta branch até agora mas não adentramos no significado que ela tem.

A Release (que significa Liberar) é comumente usada para indicar que o desenvolvedor terminou parte ou totalmente aquilo que estava desenvolvendo e está “liberando” o produto de seu trabalho para ser implantado em algum ambiente. A isto damos o nome de Release.

Mas não necessariamente a branch Release deverá implicar na implantação em algum ambiente, ainda mais quando estamos com vários desenvolvedores mexendo em suas Features e submetendo o merge request para a Release! Imagine várias pessoas fazendo isso em paralelo, quantas vezes a pipeline não seria iniciada!

Então vamos fazer mais uma modificação em nosso script, vamos no repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica), na pasta cicd\_frontend -> 03-Develop e observar as mudanças no script:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914365379-gKfcRzyzrA.png)

​Veja que todos os locais onde havia o atributo “only” mudamos para que os jobs só iniciem caso a branch se chame “develop”:​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914376057-oiXkDbHzu0.png)

​Também mudamos o environment para “develop”:​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914389758-eKz8ZM99uo.png)

Suba o script alterado e depois faça o merge request da “main” para a “release\_1.0”. Veja que a pipeline não iniciou.

Crie uma branch nova chamada “develop” à partir da branch “release\_1.0”.

Veja que agora sim o pipeline iniciou, pois devido ao atributo “only” no script, somente alterações na branch “develop” iniciam os jobs.

Note também lá em “Deployments” -> “Environments” que surgiu um novo ambiente chamado “develop”, pois isso também alteramos no job “Criar\_Container”.

Ok, mas e se eu propositadamente quiser fazer a implantação a cada Release com a alteração que eu fiz só pra ver como ficou?

É possível com o que chamamos de “Environment Dinâmico”, iremos alterar novamente nosso script para fazer um build diferente, para a Release em questão e assim termos um container partindo da nossa Release que é diferente do container da “develop” que é do nosso ambiente de desenvolvimento.

Observação: aqui como estamos praticando tudo com o Docker da sua máquina, tanto a versão de “desenvolvimento” quanto a versão em “release” ficarão no mesmo Docker (na sua máquina), mas num ambiente real essas implantações ficariam em locais diferentes!

Então vamos fazer mais uma última modificação em nosso script, vamos no repositório [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica), na pasta cicd\_frontend -> 04-Environment\_Dinamico e observar as mudanças no script:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914402419-clCpVxlzLa.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914404029-u62uGx1vRP.png)

​Note que incluímos alguns jobs, todos específicos para branch que tenha o nome de “Release”:​​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914419024-dFDs6NtphD.png)

​Tem apenas uma coisa nova e muito importante que estamos adicionando especificamente na parte de deploy da release, olhe o “environment”:​​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914429419-i820wEHBk3.png)

Esse atributo “on\_stop” faz o seguinte: na pipeline teremos a opção de clicar num botão de parada no job Criar\_Container\_Release e assim que clicarmos nesse botão, será feito o que está no job Limpar\_Imagem\_Release, que basicamente para o container dessa nossa release se estiver rodando, depois destrói o container e por último destrói essa imagem de release. Por isso que é dinâmico, você cria algo que é para ser temporário mesmo, com a vantagem de que estamos reutilizando um job que já faz parte do processo normal da pipeline para fazer essa limpeza! Assim não fica nenhum “lixo” no meio dos containers!

Tivemos que incluir o “environment” também nesse job de Limpar\_Imagem\_Release, dá uma olhada no job e veja que ao final incluímos:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914439250-3dOcm2aoBx.png)

Incluímos o atributo “action” com o valor “stop” justamente para que o Gitlab CI/CD saiba que deverá executar este job em uma parada, também foi incluído o atributo “when” com o valor “manual”, isso é necessário para que o Gitlab CI/CD saiba que esta ação de parada será uma ação manual no console do Gitlab.

Note que também criamos algumas variáveis novas, utilizadas nestes jobs novos:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914451425-yC09nRtUh7.png)

Nós estamos aqui criando um container paralelo para nosso site, só que o nome da imagem tem que ser diferente da reactsite:latest, o nome do container diferente do MeuReactSite e o número da porta no bind diferente de 3000, tudo isso pois já teremos um container rodando com essas informações que é o nosso ambiente de desenvolvimento.

Aqui ao fazermos a subida do script e merge request para a “Release\_1.0”, iremos criar uma imagem chamada reactsite:Release\_1.0, um container chamado MeuReactSite\_Release\_1.0 com um bind de porta para 3001, assim conseguiremos rodar tanto o site em desenvolvimento quanto o site mexido como se fosse um outro ambiente de Release! O $CU\_COMMIT\_REF\_NAME é uma variável interna do Gitlab CI/CD que representa o nome da branch (no nosso exemplo: release\_1.0).

Uma coisa interessante é olhar como ficou a pipeline, já que agora temos o botão de “Stop” ativo na pipeline para fazer a limpeza dessa versão de Release.

  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914479321-kSsELR1TyV.png)

​Depois que a pipeline rodar, veja como ficará no seu Docker Desktop.​​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914494503-0Jhez8aNBm.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914503542-YTJnutln8I.png)

​Agora aperte aquele botão de “Stop” no job Limpar\_Imagem\_Release. No script indicamos que ele irá parar o container de release, excluir esse container e depois excluir a imagem. Esse é nosso ambiente dinâmico, não é necessário que o container nem a imagem permaneçam, já que o que deverá valer é a versão de desenvolvimento, mas isso nos permite usar as 2 versões (release e desenvolvimento) para testes distintos que podem ser feitos pelo desenvolvedor.​​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1678914542056-cFEVNEXqji.png)

Geralmente a branch de produção é protegida para que ninguém consiga fazer um push direto para ela, sendo necessário um merge request (solicitação para mesclagem) para que o código saia de uma outra branch (geralmente de homologação) para ir para a produção.

Os times de desenvolvimento geralmente criam outras branches (geralmente chamadas de Feature) à partir da branch develop para desenvolverem em paralelo e depois fazem o merge (mesclagem) do que foi produzido nas várias features na branch develop ou entregam individualmente para fazer os testes de desenvolvimento.

Vamos brincar de “Git Flow”!

Faça agora algumas brincadeiras como criar outras branches à partir da “release\_1.0” chamada de “feature\_A” e “feature\_B” e mexa nestas branches, depois faça o merge request da “feature\_A” para a “release\_1.0” e depois outro merge request da “feature\_B” para a “release\_1.0”.

Aqui fizemos o ciclo de um time de desenvolvimento, onde temos nossa Release realmente preparada para ir para o ambiente de desenvolvimento, vamos fazer o seguinte: faça um merge request da “Release” para a “Develop” e observe o pipeline.

**Atividade Extra**

Para se aprofundar no assunto desta aula leia o documentário de referência oficial: “Environments and deployments”.

Link do documento: [https://docs.gitlab.com/ee/ci/environments/](https://docs.gitlab.com/ee/ci/environments/)

**Referência Bibliográfica**

OGURA, Everton J. **Repositório do GitLab, projeto Descomplica**. Disponível em [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica). Acesso em 26 de junho de 2022.

.gitlab-ci.yml **keyword reference**. Disponível em [https://docs.gitlab.com/ee/ci/yaml/](https://docs.gitlab.com/ee/ci/yaml/). Acesso em 26 de junho de 2022.

**Predefined variables reference**. Disponível em [https://docs.gitlab.com/ee/ci/variables/predefined\_variables.html](https://docs.gitlab.com/ee/ci/variables/predefined_variables.html). Acesso em 26 de junho de 2022.