## Acessando "de dentro" e "de fora"

Como vimos anteriormente, há um conceito em relação ao “host”, isto é, a base que sustenta tudo em relação ao funcionamento dos containers e os containers em si que “rodam em cima” do “host”. Os containers usam CPU, memória e disco do “host” como se pegassem um pedacinho emprestado o suficiente para que o container se sustente.

Falando um pouco de comunicação, isso também se aplica à interface de redes, ou seja, se um container precisar “sair para a internet”, o container usa no final do dia a placa de rede do “host” para fazer essa conectividade, tudo gerenciado pelo Docker.

Podemos então pensar assim: todo container, independente da imagem base que a serve (um Ubuntu Linux para rodar um servidor web como o Nginx, ou uma imagem base com Java para rodar aplicações Java, que inclui a Java Virtual Machine, entre outras imagens base), é necessário separar como isso funciona de fato: o “host” não necessariamente é o sistema operacional do seu computador!

Se já percebeu aqui, foram indicados alguns exemplos de uso do Docker no Windows. Estamos usando o WSL (Windows Subsystem for Linux) em cima do Windows, isso possibilita usarmos imagens baseados em Linux para subir os containers, bem “debaixo do nariz” do Windows!

Não vamos esquecer um outro ator importante nisso tudo quando se fala em sistema operacional: o Mac da Apple. O Mac não é nem Linux, nem Windows, mas basicamente quando subimos o Docker nele, também usamos um Linux “por trás da cortina” para subir nossos containers, há algumas diferenças na abordagem do Mac em relação ao Windows, vamos detalhar um pouco:

  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072698140-bqpcvISYzU.png)

Veja que no caso do Windows, pode haver sim um “host” do Windows (geralmente utilizando uma ferramenta de virtualização como o Hyper-V), só que as imagens dos containers terão que ser obrigatoriamente Windows. Isso faz com que estes containers só rodem também no Docker cujo host seja baseado em Windows, o que limita bastante as soluções, mas pode ser que hajam sim alguns requisitos para entrarmos nesta possibilidade.

No caso do MacOS da Apple, você será obrigado a ter um “host” baseado em Linux, então não há esse problema de poder portar a solução para qualquer sistema operacional, o único requisito é que tenha um “host” Linux.

Das 3 opções (Windows, MacOS da Apple e as várias distribuições do Linux), todas podem ter “host” baseado em sistema operacional Linux, por consequência as imagens terão que ser baseadas em Linux também, só que a grande vantagem é que você consegue portar a solução para qualquer sistema operacional, desde que o Docker use como “host” o Linux. Por esta razão é preferível ter e construir imagens baseadas em Linux, você conseguirá utilizar praticamente em qualquer lugar.

Ok, agora que sabemos isso, vamos adentrar um pouco mais em relação ao sistema operacional. Revisitando um tema importante sobre a base das imagens que construímos, vimos que é possível construirmos uma imagem com a base em Ubuntu, por exemplo. Isso quer dizer que é como se o container tivesse um “mini sistema operacional”, vou exemplificar com um desenho ilustrativo para entendermos melhor:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072727921-QsyPWFgE1q.png)

Então para o Docker, o “host” Linux vai gerenciando vários mini computadores, que são os containers em Linux também, uma das coisas que este gerenciamento traz é a comunicação entre o ambiente do Windows que está rodando o Docker e os containers Linux que estão debaixo do “host”.

Mas como conseguir chamar à partir do nosso Windows um container “X” por exemplo e como saber chamar um outro container “Y”, se está tudo dentro do mesmo “host”?

A resposta é: através do bind de porta.

Eita, mas o que é bind de porta? Que treco técnico!

Vamos lá:

Imagine o lugar onde você mora, tem um monte de casas, e um carteiro precisa chegar até as casas certas para entregar as cartas endereçadas a cada pessoa. Vamos dizer que hajam 3 casas numa mesma rua, o carteiro sabe a casa certa pelo número de cada casa, que não se repetem, cada casa tem seu número individual. Assim funcionam com as portas! O “bind” é pegar o container que representaria uma “casa” e dar um “número” (ou seja, a porta) a ela!

Quem for mais técnico deve estar me xingando agora, pois não é tão simples assim, mas por hora é a maneira mais simples de fazer uma analogia para que todos entendam!

É que na prática, você pode atribuir mais de uma porta a um mesmo container, então na prática é com se uma mesma casa pudesse ter mais de um número, mesmo assim o importante é que nesse “bind”, não existem números repetidos! Uma “casa” pode até ter uns 5 números atribuídos a ela (todos diferentes entre si), mas as demais “casas” nunca poderão ter nenhum desses 5 números!

Vamos ver isso na prática, abaixo está um comando para criar um container baseado em Linux com o Nginx, que é um servidor web. O meu Docker aqui usa o WSL (Windows Subsystem for Linux) como “host” do ambiente Docker, por isso eu consigo executar containers baseados em Linux:

docker run --name NginxSemBindDePorta -d nginx

  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072756821-aCokTwgGLY.png)

​Veja que o container foi criado com uma porta, neste caso é a porta 80. Isso seria como se eu estivesse dentro da minha casa e soubesse que o meu número de porta é 80, mas eu não coloquei esse número fora da minha casa, então o carteiro nunca conseguiria chegar na minha casa.​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072781103-x5SZ7NIbu1.png)

Vamos pegar uma ajudinha no Docker Desktop já que estamos no Windows, se você olharem bem para o nosso container “NginxSemBindDePorta”, tem 4 botões à direita, mas nenhuma delas é para acessar o servidor web do Nginx neste container, isso acontece porque não fizemos o “bind de porta”, ou seja, o container não está acessível pelo Windows.

Agora vamos criar outro container com Nginx também, só que com um bind de porta:

docker run --name NginxComBindDePorta -p 9280:80 -d nginx

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072807903-WciT4gkqlG.png)

Veja que agora temos 2 coisas: o 80/tcp que já vem com o Nginx que é mais ou menos como eu estou em casa e sei o número da minha casa, já o 0.0.0.0:9280 é o tal bind de porta, significa que é como se eu colocasse um número na porta da minha casa para o carteiro encontrá-la.

Aqui vem dois detalhes interessantes: no bind de porta, o número para o “carteiro” encontrar a casa (no caso 9280) não precisa ser exatamente igual ao número interno do container (que é 80), não tem problema pois é feito um tipo de “de-para”, agora olhemos o Docker Desktop para ver a diferença:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072832100-yVofSCjUyX.png)

​Veja que agora apareceu um quinto botão, passando o mouse por cima dele fica escrito “Open in Browser” que significa “abrir no navegador”. Ao clicar neste botão o Google Chrome (que aqui é meu navegador padrão) abre e sou direcionado para o seguinte endereço: localhost:9280.​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072861120-3qxi1z7QJ7.png)

“O carteiro conseguiu chegar na casa!”, mas peraê, o que é o tal do localhost e porque não ficou 0.0.0.0:9280?

Vamos lá: pegando um pouco de conhecimento de redes mas não adentrando muito (vai um curso só disso para explicar tudo), quando indicamos 0.0.0.0 significa pode vir requisição de qualquer lugar. O qualquer lugar inclui o localhost.

O localhost por sua vez é um apelido que damos ao nosso computador local, o que tem o Windows (ou o Linux, ou o MacOS se for o seu caso), é um apelido comumente utilizado em sistemas operacionais para indicar que estamos aqui mesmo, neste local do host. Ilustrando isso:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072887503-b8TTukWVkt.png)

O localhost no final do dia é o teu computador, rodando o Windows como sistema operacional principal e tendo dentro dele o Docker rodando com o “host” em Linux. Ele consegue chegar no container com o bind de porta pois esse bind permite a entrada através de qualquer lugar (0.0.0.0, ou seja, incluindo seu localhost) traduzindo a porta 9280 para a porta 80 interna do container.

Agora vamos tentar subir mais um container com Nginx, repetindo a porta 9280 pra ver o que acontece.

docker run --name NginxComBindDePorta2 -p 9280:80 -d nginx

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072911904-3OT4lAaQPX.png)

Veja que deu erro, ele até criou o container, mas não conseguiu subir, a coluna “STATUS” está como “Created”, se tivesse subido esta coluna estaria como “Up”. Isso porque já tem um container ativo usando a porta 9280, então vimos na prática que não tem como subir 2 containers e deixá-los ativos usando a mesma porta. Eu até poderia parar o container que está usando a porta 9280 e subir essa, mas se eu tentar subir as 2 com a mesma porta vai dar pau!

Então a regra, para ficar mais claro é: se tiver bind de porta, uma mesma porta não pode ser usada por 2 ou mais containers ativos ao mesmo tempo.

Não quero deixar esse assunto muito complexo, mas ainda há mais uma coisa para olharmos: será que os containers conseguem falar com eles mesmos? Uma coisa é fazer a conexão partindo do host com o bind de porta, mas será que um container fala com o outro? Vamos descobrir:

Primeiramente, uma coisa que não comentei é que ao criar esses containers eu não indiquei a “sub-rede” à qual ambos os containers pertencem. O padrão é pertencerem à uma “sub-rede” chamada “bridge”, que existe por padrão no Docker, se você não diz nada então o container “cai” nessa “sub-rede”, vamos olhar essa “sub-rede” então com o seguinte comando:

docker network inspect bridge

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072952164-jgjFxxtyPP.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676072973724-64trYWlxdn.png)

Vemos que os 2 containers que criamos, “NginxSemBindDePorta” e o “NginxComBindDePorta” estão nessa “sub-rede”, vamos usar o comando para entrar em uma delas para chamar a outra, repare no endereço IP de ambas, sendo respectivamente 172.17.0.4 e 172.17.0.5:

docker exec -it NginxSemBindDePorta bash

Isso fará com que “entremos” no container “NginxSemBindDePorta” usando um terminal “bash”, o comando “docker exec” roda comandos em um container ativo e o parâmetro “-it” é para rodar no modo interativo, ou seja, usar o terminal no próprio Prompt de Comando do Windows.

Logo que entrar, vamos tentar chamar o Nginx do outro container, o “NginxComBindDePorta”. Lembram que era para lembrar do endereço IP? Agora vai ser muito útil, vamos usar um comando chamado “curl” para fazer uma chamada como se fosse um Google Chrome chamando o site, o comando é esse:

curl 172.17.0.5:80

Aqui eu tenho que indicar o IP do outro container para dizer aonde eu quero ir e o número da porta que é a porta padrão do Nginx dentro do container. O resultado é este:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073001224-1HWD3PeR7G.png)

É claro que como é um terminal, não tem como ver o site com aquele visual mais bonito, mas o que podemos ver aqui é que fomos respondidos. O que retornou foi o código HTML do servidor web, provavelmente do arquivo index.html que vem por padrão com a imagem do Nginx.

Agora vamos sair deste container e entrar no outro e fazer a mesma coisa, só que invertendo a chamada, primeiro eu saio do container com o seguinte comando:

exit

Depois eu entro no outro container com o seguinte comando:

docker exec -it NginxComBindDePorta bash

E de dentro deste container eu faço a chamada com o “curl” para o container “NginxSemBindDePorta”:

curl 172.17.0.4:80

O resultado da chamada ao container que não tem o bind:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073030804-sblUKKII8w.png)

​Deu certo também!!! Vou ilustrar como toda essa comunicação funcionou:​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073057444-KqyQDpAa6J.png)

Isso só foi possível pois ambos os containers estão na mesma “sub-rede”, então vamos fazer um último teste, criando um container também com Nginx só que em outra “sub-rede” que eu tenho aqui, chamado “MinhaRede”:

docker run --name NginxComBindDePorta3 --network MinhaRede -p 9380:80 -d nginx

  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073082085-kbkK5yKuiN.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073105585-WjN41TvA7V.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073127122-YjCJOphl3H.png)

Entrando no container (veja o IP diferente, não começa mais com 172.17, agora começa com 172.18, isso é porque as “sub-redes” são diferentes!):

docker exec -it NginxComBindDePorta3 bash

E vamos tentar chamar primeiro aquele container NginxComBindDePorta primeiro, já que ele tem bind de porta e aceita requisição de qualquer lugar (0.0.0.0):

curl 172.17.0.5:9280

Usei a porta 9280 pois é a que está disponível “pra fora”, mas também poderia tentar na porta 80:

curl 172.17.0.5:80

Será que funcionou? Vamos ver:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073155422-C6EhYIfMKF.png)

Não funcionou porque as “sub-redes” dentro do ambiente do Docker estão separadas e não “se enxergam”, por isso não adianta chamar de dentro do “NginxComBindDePorta3” que tem o IP começando com “172.18” o outro container chamado “NginxComBindDePorta” que tem o IP começando com “172.17”. Na real dentro do “172.18” é como se não existisse nenhum IP “172.17”, por isso eles não se enxergam!

E se usarmos localhost, o que acontece?

curl localhost:80

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073186025-y8VaYWUuRQ.png)

​Aqui tem pegadinha: quando chamamos localhost de dentro do “NginxComBindDePorta3”, o “localhost” não é nosso Windows, é o próprio “NginxComBindDePorta3”! Lembra que eu disse que localhost existe em qualquer sistema operacional? Isso incluir nosso container que tem um “mini” sistema operacional próprio! Então chamar “localhost:80” é chamar a si próprio! A imagem à seguir ilustra isso:​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676073213503-21vqI3e1BC.png)

Nesta aula gigante vimos como funciona esse conceito de sistema operacional local, “host” e os “mini” sistemas operacionais dos containers e como eles “se conversam”.

Atividade Extra

Para se aprofundar no assunto desta aula leia o capítulo 10 da bibliografia de referência: VITALINO, J. F. N.; CASTRO, M. A. N. Descomplicando o docker. 2.ed. Brasport: 2018

Como bibliografia complementar com maior detalhamento sobre imagens e camadas, leia o capítulo 11 da seguinte referência: POULTON, Nigel. Docker Deep Dive: Zero to Docker in a single book (English Edition). May 2020 ed. Nigel Poulton: 2020

Referência Bibliográfica

- VITALINO, J. F. N.; CASTRO, M. A. N. Descomplicando o docker. 2.ed. Brasport: 2018.