## Subindo uma solução completa

Finalmente chegamos para falar do conjunto de soluções que usaremos como modelo para aprofundar no estudo do Docker.

A primeira coisa a se fazer é baixar o repositório que preparei, neste link: [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica)

No próprio repositório tem várias instruções de como clonar o repositório e como criar algumas coisas, mas vamos com calma.

Seguiremos o seguinte desenho:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676300845103-SYTt8DuxcD.png)

Passaremos por alguns conceitos para conseguir subir essa solução toda, mas a primeira coisa a fazermos é criar uma “sub-rede” no Docker. Já vimos o potencial de “sub-rede” e a comunicação com o uso de portas e é justamente isso que faremos com essa solução.

Vamos primeiramente criar uma “sub-rede”, para isso podemos usar o seguinte comando:

docker network create -d bridge MinhaRede

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676300875485-ON4uAd55jO.png)

“docker network” é o comando do Docker para lidarmos com tudo de redes, o comando “create” indica que estamos criando uma rede (uma “sub-rede” no caso), o parâmetro “-d bridge” indica o DRIVER que usaremos que é o tipo bridge que permite a comunicação livre entre containers e o último parâmetro “MinhaRede” é um apelido para a nossa rede.

Recapitulando esse conceito, estamos criando uma “sub-rede” para que as APIs que iremos criar consigam se comunicar com os bancos de dados. Se não fizermos isso a API não “enxergará” esses bancos de dados.

Observação: em ambiente produtivo há outros mecanismos para fazer os containers enxergarem uns aos outros, mas para a prática que estamos montando aqui que será tudo em um único computador (o seu) criamos este artifício para facilitar toda a configuração.

“sub-rede” criada, então agora podemos subir as soluções. Como front-end vai falar com API e a API por sua vez vai falar com o banco de dados, é necessário que essas dependências subam primeiro para que as aplicações não dêem problema na hora de serem executadas. Por este motivo subiremos primeiramente os bancos de dados.

Vamos subir primeiro o banco de dados Oracle! As instruções completas estão no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_database/oracle](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_database/oracle)

Neste momento irei resumir os passos, então primeiramente iremos fazer o build de uma imagem do Oracle. O Oracle possui imagens oficiais, porém não são públicas e por este motivo há a necessidade de clonarmos o repositório oficial do Oracle e escolher uma das versões para fazermos o build. Então neste momento, devemos fazer o clone do seguinte repositório: [https://github.com/oracle/docker-images.git](https://github.com/oracle/docker-images.git)

No local onde você fez o clone do repositório em sua máquina, entre no conjunto de pastas “docker-images\\OracleDatabase\\SingleInstance\\dockerfiles” e abra um terminal bash do Git (o Git Bash mesmo), depois execute o seguinte comando:

./buildContainerImage.sh -v 18.4.0 -x

Dica: digite o comando mesmo, se você copiar o comando e colar no bash, vai dar um erro e não vai fazer o build! Vai levar bastante tempo para a imagem ser criada, neste momento você terá que ser um pouco paciente.

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676300910865-qszqcs2E4L.png)

​Depois que terminar o build, você verá que uma imagem nova apareceu em seu repositório local chamado “oracle/database”:​  

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676300941006-rMTIFkOhrY.png)

Antes de subir o container, prepare um conjunto de pastas para usarmos volume no container. Assim guardaremos todos os dados do banco de dados em um local específico. Crie o conjunto de pastas “oracle\\oradata” e “oracle\\setup” no local de sua preferência. No caso da pasta “oracle\\setup”, inclua nela o arquivo “script\_inicial.sql” do repositório.

Em seguida agora sim você poderá executar o seguinte comando para subir um banco de dados Oracle:

docker run --name MeuOracle --network MinhaRede -v /D/docker/volumes/oracle/oradata:/opt/oracle/oradata -v /D/docker/volumes/oracle/setup:/opt/oracle/scripts/setup -p 1521:1521 -p 5500:5500 -e ORACLE\_PWD=MinhaSenha -e ORACLE\_CHARACTERSET=AL32UTF8 -d oracle/database:18.4.0-xe

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_database/oracle](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_database/oracle)

Na primeira vez que subir o Oracle, levará bastante tempo para ele fazer a configuração inicial (aqui levou de 30 a 40 minutos).

Agora vamos nos conectar com o Oracle SQL Developer, as instruções de como instalar a ferramenta e configurar a conexão com o usuário criado no “script\_inicial.sql” chamado MeuUsuario estão no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_database/oracle](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_database/oracle). Vamos executar o script “script\_tabelas.sql” que está neste repositório, isso criará nossas tabelas de exemplo:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676300972105-a0oTmytZFJ.png)

Agora vamos subir o banco de dados MySQL! As instruções completas estão no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_database/mysql](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_database/mysql)

Aqui iremos resumir, então crie uma pasta chamada “mysql” em um local que você deseje, depois podemos executar o seguinte comando para subir um container:

docker run --name MeuMySQL --network MinhaRede -v /D/docker/volumes/mysql:/var/lib/mysql -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=Minha@senha -e MYSQL\_USER=MeuUsuario -e MYSQL\_PASSWORD=MinhaSenha -d mysql:latest

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_database/mysql](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_database/mysql)

Agora vamos nos conectar com o MySQL Workbench as instruções de como instalar a ferramenta e configurar a conexão com o usuário root e com o usuário customizado criado chamado e MeuUsuario estão no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_database/mysql](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_database/mysql). Vamos executar o script “script\_inicial.sql” primeiramente com o usuário root para criar o schema novo e dar permissão ao usuário MeuUsuario que criamos e logo em seguida executaremos o script “script\_tabelas.sql” que está neste repositório também só que com o usuário MeuUsuario, isso criará nossas tabelas de exemplo:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301011707-MNOonU78CN.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301043708-Pcz8GVOXPu.png)

Agora vamos subir nossos back-ends! Primeiro vou começar com a API em Java SpringBoot que se conecta ao banco de dados Oracle. As instruções completas estão no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/springbootapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/springbootapi)

Neste caso já há código pronto! Iremos fazer o build do projeto para criar uma imagem desta aplicação customizada e depois subir um container. Vamos olhar o Dockerfile desta solução em Java:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301070548-MPSZzaWYz8.png)

Resumidamente, o Dockerfile instrui o uso de uma imagem base do Java especificamente para efetuar a compilação do nosso código em java, neste caso a imagem é a “maven:3.8.5-openjdk-17-slim”. Como o projeto do Java utiliza o repositório do Maven para obter as bibliotecas necessárias para o projeto, usamos essas imagem base do Maven com Java para compilar o projeto. Após a compilação do projeto e geração do arquivo “.jar”, temos a parte final que usa uma imagem base “openjdk:17-slim” especificamente para executar nosso projeto compilado quando um container for criado à partir desta imagem. É exposta a porta 8080 como porta do container para receber as requisições, note que o comando para executar nossa aplicação quando o container é iniciado é o seguinte: “java -jar /usr/local/lib/springbootapi.jar”.

O detalhamento de cada linha deste Dockerfile se encontra no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/springbootapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/springbootapi)

Podemos usar o seguinte comando para fazer o build da nossa aplicação API Java SpringBoot:

docker build --label springbootapi --no-cache -t springbootapi:latest .

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/springbootapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/springbootapi)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301104950-RI30XQgfKS.png)

E por fim podemos criar um container com o seguinte comando:

docker run --name MeuSpringBootAPI --network MinhaRede -p 8080:8080 -d springbootapi:latest

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/springbootapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/springbootapi)

Agora vamos subir nossa segunda aplicação back-end, nosso API Python FastAPI que conecta ao banco de dados MySQL. As instruções completas estão no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/pythonapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/pythonapi)

Neste caso já há código pronto! Iremos fazer o build do projeto para criar uma imagem desta aplicação customizada e depois subir um container. Vamos olhar o Dockerfile desta solução em Python:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301153786-TG7m4mc4uB.png)

No caso do Python, não há necessidade de se compilar o código, então este Dockerfile apenas indica o uso da imagem base “python:3.6-slim” e demais códigos que trazem para dentro da imagem todas as bibliotecas usadas no projeto e seus códigos-fonte. É exposta a porta 8000 como porta do container para receber as requisições, note que o comando para executar nossa aplicação quando o container é iniciado é o seguinte: “uvicorn app.main:app --host 0.0.0.0 --port 8000”.

O detalhamento de cada linha deste Dockerfile se encontra no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/pythonapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/pythonapi)

Podemos usar o seguinte comando para fazer o build da nossa aplicação API Python FastAPI:

docker build --label pythonapi --no-cache -t pythonapi:latest .

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/pythonapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/pythonapi)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301182431-E4Xq9wMesH.png)

E por fim podemos criar um container com o seguinte comando:

docker run --name MeuPythonAPI --network MinhaRede -p 8000:8000 -d pythonapi:latest

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_backend/pythonapi](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_backend/pythonapi)

E por último vamos dar uma olhada em nosso site feito com React, que conecta nas duas APIs que subimos, em Java e em Python! As instruções completas estão no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_frontend/meusite](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_frontend/meusite)

Vamos dar uma olhada no Dockerfile:

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301211389-dsVYXzABGE.png)

O detalhamento de cada linha deste Dockerfile se encontra no link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_frontend/meusite](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_frontend/meusite)

Podemos usar o seguinte comando para fazer o build da nossa aplicação React:

docker build --label reactsite --no-cache -t reactsite:latest .

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_frontend/meusite](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_frontend/meusite)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301236752-e5GkvpQYMj.png)

E por fim podemos criar um container com o seguinte comando:

docker run --name MeuReactSite --network MinhaRede -p 3000:3000 -d reactsite:latest

Os detalhes de cada parâmetro estão nas instruções do link: [https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd\_frontend/meusite](https://gitlab.com/everton.juniti/descomplica/-/tree/main/cicd_frontend/meusite)

Depois de tudo isso, podemos ver que todos os containers estão de pé: os bancos de dados Oracle (na porta 1521) e MySQL (na porta 3306), as APIs Java (na porta 8080) e Python (na porta 8000) e nosso site React (na porta 3000).

O site se comunica com as APIs e as APIs se comunicam com os bancos de dados!

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301266352-FYzDZaAfpV.png)

Podemos usar o seguinte comando para verificar que todos esses containers estão na nossa “sub-rede” chamada “MinhaRede”:

docker network inspect MinhaRede

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301296913-8qq7xEJKQC.png)

![](https://paperx-dex-assets.s3.sa-east-1.amazonaws.com/images/1676301318752-EKDhx4OBd2.png)

Atividade Extra

 

Para se aprofundar no assunto desta aula leia no detalhe o conteúdo todo do repositório: “Descomplica” no GitLab, de Everton Juniti Ogura.

Link do repositório: [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica)

Referência Bibliográfica

- OGURA, Everton J. Repositório do GitLab, projeto Descomplica. Disponível em [https://gitlab.com/everton.juniti/descomplica](https://gitlab.com/everton.juniti/descomplica). Acesso em 06 de junho de 2022.